# Зайцева Юлия Александровна, БПИ213

# Домашнее задание №2
Написание программы на Си и разработка программы на ассемблере.

## Вариант задания 24: 
Разработать программу, которая ищет в ASCII-строке заданную подстроку и возвращает список индексов первого символа для всех вхождений подстроки в строке. Подстрока вводится как параметр.


## Реализация программы на 9
1. **В коде на Си было реализовано:** 

a. Реализованы 3 функции (ввод подстроки и строки через файл и консоль, вывод результата в файл или консоль, генерация случайных наборов данных) с локальными переменными и передачей данных через параметры;

b. Есть возможность считывать данные из файла и выводить в файл (с помощью опции File);

c. Есть возможность получать данные с консоли и выводить на консоль результат;

d. Реализована генерация случайных наборов данных (с помощью опции gen). Подстрока формируется от 1 символа до 5, основная строка от 1 до 1000 символов. Данные генерируются из первой половины таблицы ASCII;

e. Использована функция clock() для получения времени работы программы.


2. **В ассемблерном коде было реализовано:** 

a. Добавлены комментарии, поясняющие эквивалентное представление переменных в программе на C. Также комментарии описывают передачу фактических параметров и перенос возвращаемого результата из функции. Также добавленные комментарии описывают связь между параметрами языка Си и регистрами;

b. Убраны лишние макросы;

c. Был произведен рефакторинг за счет максимального использования регистров процессора;

d. Функции были вынесены в отдельный файл func.s, а main находится в файле main.s;

3. **Использованные опции компиляции:** 

a. **Компиляция напрямую из Си кода в машинный:** gcc -O0 -Wall -fno-asynchronous-unwind-tables main.c -o c

b. **Получение ассемблерного кода:** gcc -O0 -Wall -fno-asynchronous-unwind-tables -S main.c -o assemble.s

c. **Получение исполняемого файла:** gcc assemble.s -o assemble

4. **Тестовое покрытие:** 

Результат в программе на Си:

1. При работе с файлами:

Ввод

![ФАйл](https://user-images.githubusercontent.com/97798186/200024909-dd794c28-111b-4cf5-b1b8-965c27ac5d89.jpg)

Вывод

![ФАйл](https://user-images.githubusercontent.com/97798186/200025062-fa74dea5-a5cf-43e2-afeb-fd42815ef711.jpg)

2. При генерации данных:

Сгенерирована подстрока, строка и вывод

![ФАйл](https://user-images.githubusercontent.com/97798186/200025767-18a753a0-3536-47da-8fa0-5ef99471f34e.jpg)

Результат в программе на Ассемблере:

1. При работе с файлами:

Ввод - аналогичный файл, как в программе на Си

![ФАйл](https://user-images.githubusercontent.com/97798186/200024909-dd794c28-111b-4cf5-b1b8-965c27ac5d89.jpg)

И аналогичный вывод

![ФАйл](https://user-images.githubusercontent.com/97798186/200025062-fa74dea5-a5cf-43e2-afeb-fd42815ef711.jpg)

2. При генерации данных:

Сгенерирована подстрока, строка и вывод

![ФАйл](https://user-images.githubusercontent.com/97798186/200028817-9addb63a-d108-445d-b235-b25bb2b06461.jpg)

5. **Сравнение на производительность:** 

a. Для сравнения был сгенерирован файл B из всех символов первой половины таблицы ASCII, состоящий из 3340746 символов. Была зациклена 100000 часть программы, отвечающая за вычисления. Была использована функция clock().

Сначала была протестирована программа на Си. Ее результат:

![ФАйл](https://user-images.githubusercontent.com/97798186/200580898-9609b33a-06b7-4393-b810-49a0b35e6470.jpg)

Затем протестировали программу на ассемблере:

![ФАйл](https://user-images.githubusercontent.com/97798186/200581125-cf65b69f-1b87-4b62-bac0-27a2c78cffe6.jpg)

Вывод: программа на ассемблере работает немного быстрее.

6. **Сравнение по ассемблерных программ с опциями оптимизации:** 

a. Использование опций оптимизаций по скорости. Были использованы следующие оптимизации: -O3 и -pipe

b. Использование опций оптимизаций по размеру. Были использованы такие оптимизации: -Os, -fomit-frame-pointer

c. Также были изучены другие опции: -O1, O2, Ofast.

Результаты тестирований (без учета времени ввода данных) представлены в таблице:

![ФАйл](https://user-images.githubusercontent.com/97798186/200578646-a79b7dfc-8d5e-4f10-94b8-a884e0b66d54.jpg)

Для получения времени тестирования был использован файл В и запущен 100000 раз. Самые долгие показатели у программы без рефакторинга и у программы с опцией -О1. Следующие по производительности идут программы с опциями -О2 и -Оfast. Производительность программы с рефакторингом практически не отличается от производительности программы с оптимизацией по размеру. Программа с опциями оптимизации по скорости оказалась самой быстрой.



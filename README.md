# Зайцева Юлия Александровна, БПИ213

# Домашнее задание №2
Написание программы на Си и разработка программы на ассемблере.

## Вариант задания 24: 
Разработать программу, которая ищет в ASCII-строке заданную подстроку и возвращает список индексов первого символа для всех вхождений подстроки в строке. Подстрока вводится как параметр.


## Реализация программы на 8
1. **В коде на Си было реализовано:** 

a. Реализованы 3 функции (ввод подстроки и строки через файл и консоль, вывод результата в файл или консоль, генерация случайных наборов данных) с локальными переменными и передачей данных через параметры;

b. Есть возможность считывать данные из файла и выводить в файл (с помощью опции File);

c. Есть возможность получать данные с консоли и выводить на консоль результат;

d. Реализована генерация случайных наборов данных (с помощью опции gen). Подстрока формируется от 1 символа до 5, основная строка от 1 до 1000 символов. Данные генерируются из первой половины таблицы ASCII;

e. Использована функция clock() для получения времени работы программы.


2. **В ассемблерном коде было реализовано:** 

a. Добавлены комментарии, поясняющие эквивалентное представление переменных в программе на C. Также комментарии описывают передачу фактических параметров и перенос возвращаемого результата из функции. Также добавленные комментарии описывают связь между параметрами языка Си и регистрами;

b. Убраны лишние макросы;

c. Был произведен рефакторинг за счет максимального использования регистров процессора;

d. Функции были вынесены в отдельный файл func.s, а main находится в файле main.s;

3. **Использованные опции компиляции:** 

a. **Компиляция напрямую из Си кода в машинный:** gcc -O0 -Wall -fno-asynchronous-unwind-tables main.c -o c

b. **Получение ассемблерного кода:** gcc -O0 -Wall -fno-asynchronous-unwind-tables -S main.c -o assemble.s

c. **Получение исполняемого файла:** gcc assemble.s -o assemble

4. **Тестовое покрытие:** 

Результат в программе на Си:

1. При работе с файлами:

Ввод

![ФАйл](https://user-images.githubusercontent.com/97798186/200024909-dd794c28-111b-4cf5-b1b8-965c27ac5d89.jpg)

Вывод

![ФАйл](https://user-images.githubusercontent.com/97798186/200025062-fa74dea5-a5cf-43e2-afeb-fd42815ef711.jpg)

2. При генерации данных:

Сгенерирована подстрока, строка и вывод

![ФАйл](https://user-images.githubusercontent.com/97798186/200025767-18a753a0-3536-47da-8fa0-5ef99471f34e.jpg)

Результат в программе на Ассемблере:

1. При работе с файлами:

Ввод - аналогичный файл, как в программе на Си

![ФАйл](https://user-images.githubusercontent.com/97798186/200024909-dd794c28-111b-4cf5-b1b8-965c27ac5d89.jpg)

И аналогичный вывод

![ФАйл](https://user-images.githubusercontent.com/97798186/200025062-fa74dea5-a5cf-43e2-afeb-fd42815ef711.jpg)

2. При генерации данных:

Сгенерирована подстрока, строка и вывод

![ФАйл](https://user-images.githubusercontent.com/97798186/200028817-9addb63a-d108-445d-b235-b25bb2b06461.jpg)

5. **Сравнение на производительность:** 

1. Для сравнения был создан файл А из 2661225 буквенных символов, а затем использован для вычисления времени, необходимого для его обработки обеими программами. Была использована функция clock().

Сначала была протестирована программа на Си. Ее результат:

![ФАйл](https://user-images.githubusercontent.com/97798186/200031330-19e4289f-903f-421a-bb75-06ecd45a2f43.jpg)

Было сделано несколько прогонов: время работы варьировалось от 12 до 20 секунд. Среднее время работы программы: 14 секунд.

Затем протестировали программу на ассемблере:

![ФАйл](https://user-images.githubusercontent.com/97798186/200031504-b4ff7b4c-3e08-4158-a71c-40373697020c.jpg)

Также было сделано несколько прогонов: время работы варьировалось от 14 до 21 секунды. Среднее время работы: 16 секунд.

Вывод: программа на ассемблере работает немного дольше. Отличие среднего времени работы программ заключается в двух секундах.

2. Для сравнения был создан файл B из всех символов первой половины таблицы ASCII, состоящий из 3340746 символов. Время работы программы на Си составило от 24 до 32 секунд. Время работы программы на ассемблере: от 30 до 41 секунды. С увеличением количества символов, которые необходимо обработать, время работы ассемблерной программы увеличивается, по сравнению с временем работы программы на Си.

6. **Сравнение по ассемблерных программ с опциями оптимизации:** 

1. Использование опций оптимизаций по скорости. Были использованы следующие оптимизации: -O3 и -pipe

2. Использование опций оптимизаций по размеру. Были использованы такие оптимизации: -Os, -fomit-frame-pointer

3. Также были изучены другие опции: -O1, O2, Ofast.

Результаты тестирований (вместе с временем ввода данных) представлены в таблице:

![ФАйл](https://user-images.githubusercontent.com/97798186/200049156-246d6df0-a6bf-4822-9ae2-9198e618450c.jpg)

Рефакторинг исходной программы поспособствовал увеличению производительности в 1.5 раза, но и привел к увеличению строчек кода. Опции оптимизации по размеру помогли уменьшить количество строчек кода, а также привели практически к такой же производительности, как у программы после рефакторинга. Наиболее выигрышная по производительности - программа с опциями оптимизации по скорости.

Программа с опцией -О1 имеет почти наименьшее кол-во строчек кода, но у нее не самая лучшая производительность. Программы с опциями -О2 и -Оfast практически ничем не отличаются друг от друга, но у них такая же производительность, как и у программы после рефакторинга.

Результаты тестирований (без учета времени ввода данных) представлены в таблице:

![ФАйл](https://user-images.githubusercontent.com/97798186/200055262-5c84b5f1-2e99-49e1-afb7-357dbb3c6a59.jpg)

Можно сделать вывод, что формирование массивов строк занимает наибольшую часть времени. Самые лучшие по производительности: программа после рефакторинга, программа с оптимизациями по скорости. Самая худшая: программа до рефакторинга. Все остальные программы примерно одинаковы по производительности.
